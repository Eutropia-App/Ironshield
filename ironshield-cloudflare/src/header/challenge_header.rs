use crate::header::util::deserialize_signature;
use crate::header::util::serialize_signature;
use chrono::Utc;
use serde::{Deserialize, Serialize};

/// * `random_nonce`:     The SHA-256 hash of a random number.
/// * `created_time`:     Unix milli timestamp for the challenge.
/// * `expiration_time`:  Unix milli timestamp for the challenge
///                       expiration time. (created_time + 30 ms)
/// * `challenge_params`: Challenge difficulty parameter or target
///                       number of leading zeros in the hash.
/// * `website_id`:       The identifier of the website.
/// * `public_key`:       Ed25519 public key for signature verification.
/// * `signature`:        Ed25519 signature over 
///                       (`random_nonce || created_time || expiration_time
///                       || challenge_params`).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallenge {
    pub random_nonce:        String,
    pub created_time:        i64,
    pub expiration_time:     i64,
    pub website_id:          String,
    pub challenge_params:    u8,
    pub public_key:          [u8; 32],
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
}

impl IronShieldChallenge {
    /// Constructor, this creates a new `IronShieldChallenge` instance.
    ///
    /// # Arguments
    ///
    /// * `random_nonce`:     The SHA-256 hash of a random number.
    /// * `created_time`:     Unix milli timestamp for the challenge
    ///                       creation time.
    /// * `challenge_params`: Unix milli timestamp for the challenge
    ///                       expiration time. (created_time + 30 ms)
    /// * `public_key`:       Ed25519 public key for signature
    /// * `signature`:        Ed25519 signature over (`random_nonce ||
    ///                       created_time || expires_time ||
    ///                       challenge_params`).
    pub fn new(
        random_nonce:     String,
        created_time:     i64,
        website_id:       String,
        challenge_params: u8,
        public_key:       [u8; 32],
        signature:        [u8; 64],
    ) -> Self {
        Self {
            random_nonce,
            created_time,
            website_id,
            expiration_time: created_time + 30_000,
            challenge_params,
            public_key,
            challenge_signature: signature,
        }
    }

    /// Check if the challenge has expired.
    pub fn is_expired(&self) -> bool {
        Utc::now().timestamp_millis() > self.expiration_time
    }

    /// Returns the remaining time until the
    /// expiration in milliseconds.
    pub fn time_until_expiration(&self) -> i64 {
        self.expiration_time - Utc::now().timestamp_millis()
    }

    /// Concatenates the challenge data into a string.
    ///
    /// Concatenates:
    /// - `random_nonce`     as a string.
    /// - `created_time`     as i64.
    /// - `expiration_time`  as i64.
    /// - `website_id`       as a string.
    /// - `public_key`       as a lowercase hex string.
    /// - `challenge_params` as a lowercase hex string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}|{}|{}|{}|{}|{}",
            self.random_nonce,
            self.created_time,
            self.expiration_time,
            self.website_id,
            self.challenge_params,
            // Use of hex::encode to convert the public key to a hex string
            // "Encodes data as hex string using lowercase characters."
            // Requirement of `format!`.
            hex::encode(self.public_key),
            hex::encode(self.challenge_signature)
        )
    }

    /// Creates an `IronShieldChallenge` from a concatenated string.
    ///
    /// This function reverses the operation of
    /// `IronShieldChallenge::concat_struct`.
    /// Expects a string in the format:
    /// "random_nonce|created_time|expiration_time|website_id|challenge_params|public_key|challenge_signature"
    ///
    /// # Arguments
    ///
    /// * `concat_str`: The concatenated string to parse, typically
    ///                 generated by `concat_struct()`.
    ///
    /// # Returns
    ///
    /// * `Result<Self, String>`: A result containing the parsed
    ///                           `IronShieldChallenge` or an 
    ///                           error message if parsing fails.
    pub fn from_concat_struct(concat_str: &str) -> Result<Self, String> {
        let parts: Vec<&str> = concat_str.split('|').collect();

        if parts.len() != 7 {
            return Err(format!("Expected 7 parts, got {}", parts.len()));
        }

        let random_nonce = parts[0].to_string();

        let created_time = parts[1].parse::<i64>()
            .map_err(|_| "Failed to parse created_time as i64")?;

        let expiration_time = parts[2].parse::<i64>()
            .map_err(|_| "Failed to parse expiration_time as i64")?;

        let website_id = parts[3].to_string();

        let challenge_params = parts[4].parse::<u8>()
            .map_err(|_| "Failed to parse challenge_params as u8")?;

        let public_key_bytes = hex::decode(parts[5])
            .map_err(|_| "Failed to decode public_key hex string")?;
        let public_key: [u8; 32] = public_key_bytes.try_into()
            .map_err(|_| "Public key must be exactly 32 bytes")?;

        let signature_bytes = hex::decode(parts[6])
            .map_err(|_| "Failed to decode challenge_signature hex string")?;
        let challenge_signature: [u8; 64] = signature_bytes
            .try_into()
            .map_err(|_| "Signature must be exactly 64 bytes")?;

        Ok(Self {
            random_nonce,
            created_time,
            expiration_time,
            website_id,
            challenge_params,
            public_key,
            challenge_signature,
        })
    }
}