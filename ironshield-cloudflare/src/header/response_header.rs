use crate::header::util::deserialize_signature;
use crate::header::util::serialize_signature;
use serde::{Deserialize, Serialize};

/// * `challenge_signature`: The Ed25519 signature of the challenge.
///                          Used to verify the integrity of each 
///                          *different* challenge attempt, this 
///                          ensures that signatures may not be 
///                          reused across different challenges.
/// * `solution`             The solution to the challenge provided
///                          to the client, by the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallengeResponse {
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
    pub solution:            i64,
}

impl IronShieldChallengeResponse {
    pub fn new(
        challenge_signature: [u8; 64], 
        solution: i64
    ) -> Self {
        Self {
            challenge_signature,
            solution,
        }
    }

    /// Concatenates the token data into a string.
    /// 
    /// Concatenates:
    /// - `challenge_signature` as a lowercase hex string.Add commentMore actions
    /// - `valid_for`:          as a string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}",
            // Use of hex::encode to convert the public key to a hex string
            // "Encodes data as hex string using lowercase characters."
            // Requirement of `format!`.
            hex::encode(self.challenge_signature),
            self.solution
        )
    }

    /// Parses a concatenated string back into an ` IronShieldChallengeResponse `.
    /// Struct.
    /// 
    /// This function reverses the operation of 
    /// `IronShieldChallengeResponse::concat_struct`.
    /// Expects a string in the format: "hex_signature|solution".
    /// 
    /// # Arguments
    /// * `concat_string`: The concatenated string to parse, typically 
    ///                    generated by `concat_struct()`.
    /// 
    /// # Returns
    /// * A Result containing the parsed `IronShieldChallengeResponse`
    ///   or an error message if parsing fails.
    pub fn from_concat_struct(concat_string: &str) -> Result<IronShieldChallengeResponse, String> {
        // Split the concatenated string by the '|' character.
        let parts: Vec<&str> = concat_string.split('|').collect();
        
        // Ensure there are exactly 2 parts: signature and solution.
        if parts.len() != 2 {
            return Err(format!("Expected 2 parts separated by '|', got {}", parts.len()));
        }
        
        // Decode the first part as a hex string.
        let signature_bytes = hex::decode(parts[0])
            .map_err(|e| format!("Failed to decode hex signature: {}", e ))?;
        
        // Ensure the signature is exactly 64 bytes.
        if signature_bytes.len() != 64 {
            return Err(format!("Expected 64 bytes for signature, got {}", signature_bytes.len()));
        }
        
        // Create a fixed-size array from the decoded bytes.
        let mut challenge_signature = [0u8; 64];
        challenge_signature.copy_from_slice(&signature_bytes);
        
        // Parse the solution as an i64.
        let solution = parts[1].parse::<i64>()
            .map_err(|e| format!("Failed to parse solution: {}", e))?;
        
        // Return the new IronShieldChallengeResponse instance.
        Ok(IronShieldChallengeResponse::new(challenge_signature, solution))
    }
}